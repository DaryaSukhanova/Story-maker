<svg xmlns="http://www.w3.org/2000/svg" width="1000" height="1000" viewbox="0 0 1000 1000"><circle fill="rgba(35, 170, 232, 1)" stroke="rgba(220, 101, 241, 1)" stroke-width="2" data-tool="true" cx="153" cy="118" r="33.015148038438355" id="animatedElementId"></circle><path stroke="#8DADFF" stroke-width="2" fill="none" id="motionPath" d="M 197 282 L 198 282 L 202 280 L 208 276 L 217 272 L 228 268 L 245 265 L 261 263 L 278 261 L 299 260 L 317 260 L 337 260 L 360 260 L 382 260 L 406 259 L 424 257 L 442 254 L 461 249 L 477 244 L 488 239 L 501 232 L 508 226 L 514 222 L 520 216 L 523 211 L 525 207 L 527 204 L 528 204 L 530 204 L 534 203 L 545 203 L 560 203 L 577 203 L 600 203 L 618 204 L 634 205 L 646 205 L 655 208 L 661 210 L 665 211 L 670 211 L 675 211 L 684 210 L 694 206 L 703 201 L 711 197 L 719 192 L 726 188 L 732 185 L 738 182 L 743 181 L 752 179 L 762 179 L 773 179 L 784 179 L 795 179 L 805 178 L 816 178 L 822 176 L 828 174"></path><script>
            <![CDATA[
                this.play = true
                this.currentSpeed = 8
                let distanceCovered = 0;
                let isAnimationSaved = false;
                let isUpdateTime = false
                function animate(element) {
    const motionPath = document.getElementById('motionPath');
    const totalLength = motionPath.getTotalLength();
    distanceCovered = 0;
    let speed = this.currentSpeed;
    element.setAttribute("x", 0);
    element.setAttribute("y", 0);
    if (element.hasAttribute("r")) {
      element.setAttribute("cx", 0);
      element.setAttribute("cy", 0);
    }
    const moveAlongPath = () => {
      if (this.play) {
        const point = motionPath.getPointAtLength(distanceCovered);
        if (element.hasAttribute("d") || element.hasAttribute("points")) {
          const initialX = element.getPointAtLength(0).x;
          const initialY = element.getPointAtLength(0).y;
          element.setAttribute("transform", `translate(${point.x - initialX} ${point.y - initialY})`);
        } else {
          element.setAttribute("transform", `translate(${point.x} ${point.y})`);
        }
        speed = this.currentSpeed;
        distanceCovered += speed;
        if (distanceCovered <= totalLength) {
          requestAnimationFrame(moveAlongPath);
        } else {
          distanceCovered = 0;
          const newStartTime = Date.now();
          if (isUpdateTime) {
            _store_animationToolState__WEBPACK_IMPORTED_MODULE_1__["default"].setStartTime(newStartTime);
          }
          requestAnimationFrame(moveAlongPath);
          if (_store_animationToolState__WEBPACK_IMPORTED_MODULE_1__["default"].isAnimationSaved) {
            console.log("isSave");
            this.saveAnimatedSvg();
            _store_animationToolState__WEBPACK_IMPORTED_MODULE_1__["default"].isAnimationSaved = false;
          }
        }
        motionPath.style.display = "none";
      } else {
        requestAnimationFrame(moveAlongPath);
        motionPath.style.display = "block";
      }
    };
    moveAlongPath();
  }
                const animatedElement = document.getElementById('animatedElementId');
                animate(animatedElement);
            ]]>
        </script></svg>